

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>OCC.CSLib module &mdash; pythonocc API 0.18 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pythonocc API 0.18 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pythonocc API
          

          
          </a>

          
            
            
              <div class="version">
                0.18
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">OCC.CSLib module</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pythonocc API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>OCC.CSLib module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/OCC.CSLib.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="occ-cslib-module">
<h1>OCC.CSLib module<a class="headerlink" href="#occ-cslib-module" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-OCC.CSLib"></span><dl class="class">
<dt id="OCC.CSLib.CSLib_Class2d">
<em class="property">class </em><code class="descname">CSLib_Class2d</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>TP</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>aTolu</strong> (<em>float</em>) – </li>
<li><strong>aTolv</strong> (<em>float</em>) – </li>
<li><strong>umin</strong> (<em>float</em>) – </li>
<li><strong>vmin</strong> (<em>float</em>) – </li>
<li><strong>umax</strong> (<em>float</em>) – </li>
<li><strong>vmax</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.Copy">
<code class="descname">Copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.Copy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Other</strong> (<em>CSLib_Class2d &amp;</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#OCC.CSLib.CSLib_Class2d" title="OCC.CSLib.CSLib_Class2d">CSLib_Class2d</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.Destroy">
<code class="descname">Destroy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.Destroy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.InternalSiDans">
<code class="descname">InternalSiDans</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.InternalSiDans" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>float</em>) – </li>
<li><strong>Y</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.InternalSiDansOuOn">
<code class="descname">InternalSiDansOuOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.InternalSiDansOuOn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>float</em>) – </li>
<li><strong>Y</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.Set">
<code class="descname">Set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.Set" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Other</strong> (<em>CSLib_Class2d &amp;</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#OCC.CSLib.CSLib_Class2d" title="OCC.CSLib.CSLib_Class2d">CSLib_Class2d</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.SiDans">
<code class="descname">SiDans</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.SiDans" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.CSLib_Class2d.SiDans_OnMode">
<code class="descname">SiDans_OnMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.SiDans_OnMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Tol</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="OCC.CSLib.CSLib_Class2d.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#OCC.CSLib.CSLib_Class2d.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="OCC.CSLib.CSLib_NormalPolyDef">
<em class="property">class </em><code class="descname">CSLib_NormalPolyDef</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.CSLib_NormalPolyDef" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="OCC.math.html#OCC.math.math_FunctionWithDerivative" title="OCC.math.math_FunctionWithDerivative"><code class="xref py py-class docutils literal"><span class="pre">OCC.math.math_FunctionWithDerivative</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k0</strong> (<em>int</em>) – </li>
<li><strong>li</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="OCC.CSLib.CSLib_NormalPolyDef.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#OCC.CSLib.CSLib_NormalPolyDef.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="OCC.CSLib.SwigPyIterator">
<em class="property">class </em><code class="descname">SwigPyIterator</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.advance">
<code class="descname">advance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.decr">
<code class="descname">decr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.decr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.distance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.equal">
<code class="descname">equal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.incr">
<code class="descname">incr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.incr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.previous">
<code class="descname">previous</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="OCC.CSLib.SwigPyIterator.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="OCC.CSLib.SwigPyIterator.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.SwigPyIterator.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="OCC.CSLib.cslib">
<em class="property">class </em><code class="descname">cslib</code><a class="headerlink" href="#OCC.CSLib.cslib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="staticmethod">
<dt id="OCC.CSLib.cslib.DNNUV">
<em class="property">static </em><code class="descname">DNNUV</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.cslib.DNNUV" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>– Computes the derivative of order Nu in the – direction U and Nv in the direction V of the not – normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Nu</strong> (<em>int</em>) – </li>
<li><strong>Nv</strong> (<em>int</em>) – </li>
<li><strong>DerSurf</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec">gp_Vec</a></p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Nu</strong> (<em>int</em>) – </li>
<li><strong>Nv</strong> (<em>int</em>) – </li>
<li><strong>DerSurf1</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
<li><strong>DerSurf2</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec">gp_Vec</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.CSLib.cslib.DNNormal">
<em class="property">static </em><code class="descname">DNNormal</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.cslib.DNNormal" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>– Computes the derivative of order Nu in the – direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Nu</strong> (<em>int</em>) – </li>
<li><strong>Nv</strong> (<em>int</em>) – </li>
<li><strong>DerNUV</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
<li><strong>Iduref</strong> (<em>int</em>) – default value is 0</li>
<li><strong>Idvref</strong> (<em>int</em>) – default value is 0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec">gp_Vec</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.CSLib.cslib.Normal">
<em class="property">static </em><code class="descname">Normal</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.cslib.Normal" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>The following functions computes the normal to a surface inherits FunctionWithDerivative from math //! Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if Status == Done else the Status gives the reason why the computation has failed.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D1U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D1V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>SinTol</strong> (<em>float</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_DerivativeStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps-&gt;0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| //! . if DNu IsNull (DNu &lt;= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv &lt;= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D1U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D1V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D2U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D2V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D2UV</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>SinTol</strong> (<em>float</em>) – </li>
<li><strong>Done</strong> (<em>bool</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_NormalStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Computes the normal direction of a surface as the cross product between D1U and D1V.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D1U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D1V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>MagTol</strong> (<em>float</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_NormalStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>find the first order k0 of deriviative of NUV where: foreach order &lt; k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>MaxOrder</strong> (<em>int</em>) – </li>
<li><strong>DerNUV</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
<li><strong>MagTol</strong> (<em>float</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>V</strong> (<em>float</em>) – </li>
<li><strong>Umin</strong> (<em>float</em>) – </li>
<li><strong>Umax</strong> (<em>float</em>) – </li>
<li><strong>Vmin</strong> (<em>float</em>) – </li>
<li><strong>Vmax</strong> (<em>float</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_NormalStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
<li><strong>OrderU</strong> (<em>int &amp;</em>) – </li>
<li><strong>OrderV</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="OCC.CSLib.cslib.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#OCC.CSLib.cslib.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="OCC.CSLib.cslib_DNNUV">
<code class="descname">cslib_DNNUV</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.cslib_DNNUV" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>– Computes the derivative of order Nu in the – direction U and Nv in the direction V of the not – normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Nu</strong> (<em>int</em>) – </li>
<li><strong>Nv</strong> (<em>int</em>) – </li>
<li><strong>DerSurf</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec">gp_Vec</a></p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Nu</strong> (<em>int</em>) – </li>
<li><strong>Nv</strong> (<em>int</em>) – </li>
<li><strong>DerSurf1</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
<li><strong>DerSurf2</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec">gp_Vec</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.CSLib.cslib_DNNormal">
<code class="descname">cslib_DNNormal</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.cslib_DNNormal" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>– Computes the derivative of order Nu in the – direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Nu</strong> (<em>int</em>) – </li>
<li><strong>Nv</strong> (<em>int</em>) – </li>
<li><strong>DerNUV</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
<li><strong>Iduref</strong> (<em>int</em>) – default value is 0</li>
<li><strong>Idvref</strong> (<em>int</em>) – default value is 0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec">gp_Vec</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.CSLib.cslib_Normal">
<code class="descname">cslib_Normal</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.cslib_Normal" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>The following functions computes the normal to a surface inherits FunctionWithDerivative from math //! Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if Status == Done else the Status gives the reason why the computation has failed.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D1U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D1V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>SinTol</strong> (<em>float</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_DerivativeStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps-&gt;0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| //! . if DNu IsNull (DNu &lt;= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv &lt;= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D1U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D1V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D2U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D2V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D2UV</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>SinTol</strong> (<em>float</em>) – </li>
<li><strong>Done</strong> (<em>bool</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_NormalStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Computes the normal direction of a surface as the cross product between D1U and D1V.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D1U</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>D1V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>MagTol</strong> (<em>float</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_NormalStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>find the first order k0 of deriviative of NUV where: foreach order &lt; k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>MaxOrder</strong> (<em>int</em>) – </li>
<li><strong>DerNUV</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array2OfVec" title="OCC.TColgp.TColgp_Array2OfVec"><em>TColgp_Array2OfVec</em></a>) – </li>
<li><strong>MagTol</strong> (<em>float</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>V</strong> (<em>float</em>) – </li>
<li><strong>Umin</strong> (<em>float</em>) – </li>
<li><strong>Umax</strong> (<em>float</em>) – </li>
<li><strong>Vmin</strong> (<em>float</em>) – </li>
<li><strong>Vmax</strong> (<em>float</em>) – </li>
<li><strong>Status</strong> (<em>CSLib_NormalStatus &amp;</em>) – </li>
<li><strong>Normal</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Dir" title="OCC.gp.gp_Dir"><em>gp_Dir</em></a>) – </li>
<li><strong>OrderU</strong> (<em>int &amp;</em>) – </li>
<li><strong>OrderV</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.CSLib.register_handle">
<code class="descname">register_handle</code><span class="sig-paren">(</span><em>handle</em>, <em>base_object</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.CSLib.register_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts the handle into the base object to
prevent memory corruption in certain cases</p>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Thomas Paviot.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.18',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>