

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>OCC.BSplCLib module &mdash; pythonocc API 0.18 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pythonocc API 0.18 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pythonocc API
          

          
          </a>

          
            
            
              <div class="version">
                0.18
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">OCC.BSplCLib module</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pythonocc API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>OCC.BSplCLib module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/OCC.BSplCLib.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="occ-bsplclib-module">
<h1>OCC.BSplCLib module<a class="headerlink" href="#occ-bsplclib-module" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-OCC.BSplCLib"></span><dl class="class">
<dt id="OCC.BSplCLib.SwigPyIterator">
<em class="property">class </em><code class="descname">SwigPyIterator</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.advance">
<code class="descname">advance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.decr">
<code class="descname">decr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.decr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.distance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.equal">
<code class="descname">equal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.incr">
<code class="descname">incr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.incr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.previous">
<code class="descname">previous</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="OCC.BSplCLib.SwigPyIterator.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="OCC.BSplCLib.SwigPyIterator.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.SwigPyIterator.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="OCC.BSplCLib.bsplclib">
<em class="property">class </em><code class="descname">bsplclib</code><a class="headerlink" href="#OCC.BSplCLib.bsplclib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.AntiBoorScheme">
<em class="property">static </em><code class="descname">AntiBoorScheme</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.AntiBoorScheme" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Compute the content of Pole before the BoorScheme. This method is used to remove poles. //! U is the poles to remove, Knots should contains the knots of the curve after knot removal. //! The first and last poles do not change, the other poles are computed by averaging two possible values. The distance between the two possible poles is computed, if it is higher than &lt;Tolerance&gt; False is returned.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Bohm">
<em class="property">static </em><code class="descname">Bohm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Bohm" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Performs the Bohm Algorithm at parameter &lt;U&gt;. This algorithm computes the value and all the derivatives up to order N (N &lt;= Degree). //! &lt;Poles&gt; is the original array of poles. //! The result in &lt;Poles&gt; is the value and the derivatives. Poles[0] is the value, Poles[Degree] is the last derivative.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>N</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BoorIndex">
<em class="property">static </em><code class="descname">BoorIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BoorIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the index in the Boor result array of the poles &lt;Index&gt;. If the Boor algorithm was perform with &lt;Length&gt; and &lt;Depth&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BoorScheme">
<em class="property">static </em><code class="descname">BoorScheme</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BoorScheme" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Performs the Boor Algorithm at parameter &lt;U&gt; with the given &lt;Degree&gt; and the array of &lt;Knots&gt; on the poles &lt;Poles&gt; of dimension &lt;Dimension&gt;. The schema is computed until level &lt;Depth&gt; on a basis of &lt;Length+1&gt; poles. //! * Knots is an array of reals of length : //! &lt;Length&gt; + &lt;Degree&gt; //! * Poles is an array of reals of length : //! (2 * &lt;Length&gt; + 1) * &lt;Dimension&gt; //! The poles values must be set in the array at the positions. //! 0..Dimension, //! 2 * Dimension .. 3 * Dimension //! 4 * Dimension .. 5 * Dimension //! … //! The results are found in the array poles depending on the Depth. (See the method GetPole).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BuildBSpMatrix">
<em class="property">static </em><code class="descname">BuildBSpMatrix</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BuildBSpMatrix" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This Builds a fully blown Matrix of (ni) Bi (tj) //! with i and j within 1..Order + NumPoles The integer ni is the ith slot of the array OrderArray, tj is the jth slot of the array Parameters</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>OrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int &amp;</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BuildBoor">
<em class="property">static </em><code class="descname">BuildBoor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BuildBoor" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Copy in &lt;LP&gt; poles for &lt;Dimension&gt; Boor scheme. Starting from &lt;Index&gt; * &lt;Dimension&gt;, copy &lt;Length+1&gt; poles.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>LP</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BuildCache">
<em class="property">static </em><code class="descname">BuildCache</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BuildCache" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>InverseOfSpanDomain</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>InverseOfSpanDomain</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BuildEval">
<em class="property">static </em><code class="descname">BuildEval</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BuildEval" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>LP</strong> (<em>float &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>LP</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Copy in &lt;LP&gt; the poles and weights for the Eval scheme. starting from Poles(Poles.Lower()+Index)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>LP</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BuildKnots">
<em class="property">static </em><code class="descname">BuildKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BuildKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Stores in LK the usefull knots for the BoorSchem on the span Knots(Index) - Knots(Index+1)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>LK</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.BuildSchoenbergPoints">
<em class="property">static </em><code class="descname">BuildSchoenbergPoints</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.BuildSchoenbergPoints" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>builds the Schoenberg points from the flat knot used to interpolate a BSpline since the BSpline matrix is invertible.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CacheD0">
<em class="property">static </em><code class="descname">CacheD0</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CacheD0" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CacheD1">
<em class="property">static </em><code class="descname">CacheD1</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CacheD1" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CacheD2">
<em class="property">static </em><code class="descname">CacheD2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CacheD2" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CacheD3">
<em class="property">static </em><code class="descname">CacheD3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CacheD3" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CoefsD0">
<em class="property">static </em><code class="descname">CoefsD0</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CoefsD0" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CoefsD1">
<em class="property">static </em><code class="descname">CoefsD1</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CoefsD1" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CoefsD2">
<em class="property">static </em><code class="descname">CoefsD2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CoefsD2" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.CoefsD3">
<em class="property">static </em><code class="descname">CoefsD3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.CoefsD3" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.D0">
<em class="property">static </em><code class="descname">D0</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.D0" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.D1">
<em class="property">static </em><code class="descname">D1</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.D1" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.D2">
<em class="property">static </em><code class="descname">D2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.D2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>V1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>V2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.D3">
<em class="property">static </em><code class="descname">D3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.D3" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>V1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>V2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>V3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Derivative">
<em class="property">static </em><code class="descname">Derivative</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Derivative" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the poles of the BSpline giving the derivatives of order &lt;Order&gt;. //! The formula for the first order is //! Pole(i) = Degree * (Pole(i+1) - Pole(i)) / (Knots(i+Degree+1) - Knots(i+1)) //! This formula is repeated (Degree is decremented at each step).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Order</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Eval">
<em class="property">static </em><code class="descname">Eval</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Eval" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the Boor algorithm to evaluate a point at parameter &lt;U&gt;, with &lt;Degree&gt; and &lt;Dimension&gt;. //! Poles is an array of Reals of size //! &lt;Dimension&gt; * &lt;Degree&gt;+1 //! Containing the poles. At the end &lt;Poles&gt; contains the current point.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the De Boor algorithm to evaluate a point at parameter &lt;U&gt;, with &lt;Degree&gt; and &lt;Dimension&gt;. //! Poles is an array of Reals of size //! &lt;Dimension&gt; * &lt;Degree&gt;+1 //! Containing the poles. At the end &lt;Poles&gt; contains the current point. Poles Contain all the poles of the BsplineCurve, Knots also Contains all the knots of the BsplineCurve. ExtrapMode has two slots [0] = Degree used to extrapolate before the first knot [1] = Degre used to extrapolate after the last knot has to be between 1 and Degree</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>DerivativeRequest</strong> (<em>int</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Result</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the De Boor algorithm to evaluate a point at parameter &lt;U&gt;, with &lt;Degree&gt; and &lt;Dimension&gt;. Evaluates by multiplying the Poles by the Weights and gives the homogeneous result in PolesResult that is the results of the evaluation of the numerator once it has been multiplied by the weights and in WeightsResult one has the result of the evaluation of the denominator //! Warning: &lt;PolesResult&gt; and &lt;WeightsResult&gt; must be dimensionned properly.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>DerivativeRequest</strong> (<em>int</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Weights</strong> (<em>float &amp;</em>) – </li>
<li><strong>PolesResult</strong> (<em>float &amp;</em>) – </li>
<li><strong>WeightsResult</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>HomogeneousFlag</strong> (<em>bool</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Weight</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>HomogeneousFlag</strong> (<em>bool</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Weight</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.EvalBsplineBasis">
<em class="property">static </em><code class="descname">EvalBsplineBasis</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.EvalBsplineBasis" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This evaluates the Bspline Basis at a given parameter Parameter up to the requested DerivativeOrder and store the result in the array BsplineBasis in the following fashion BSplineBasis(1,1) = value of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BsplineBasis(1,2) = value of second non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + 1 BsplineBasis(1,n) = value of second non vanishing non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + n (n &lt;= Order) BSplineBasis(2,1) = value of derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BSplineBasis(N,1) = value of Nth derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex if N &lt;= DerivativeOrder + 1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Side</strong> (<em>int</em>) – </li>
<li><strong>DerivativeOrder</strong> (<em>int</em>) – </li>
<li><strong>Order</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameter</strong> (<em>float</em>) – </li>
<li><strong>FirstNonZeroBsplineIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>BsplineBasis</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>isPeriodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.FactorBandedMatrix">
<em class="property">static </em><code class="descname">FactorBandedMatrix</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.FactorBandedMatrix" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>this factors the Banded Matrix in the LU form with a Banded storage of components of the L matrix WARNING : do not use if the Matrix is totally positive (It is the case for Bspline matrices build as above with parameters being the Schoenberg points</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>PivotIndexProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.FirstUKnotIndex">
<em class="property">static </em><code class="descname">FirstUKnotIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.FirstUKnotIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the index of the knots value which gives the start point of the curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.FlatBezierKnots">
<em class="property">static </em><code class="descname">FlatBezierKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.FlatBezierKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns pointer to statically allocated array representing flat knots for bezier curve of the specified degree. Raises OutOfRange if Degree &gt; MaxDegree()</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Degree</strong> (<em>int</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.FlatIndex">
<em class="property">static </em><code class="descname">FlatIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.FlatIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the index of the flats knots sequence corresponding to &lt;Index&gt; in the knots sequence which multiplicities are &lt;Mults&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.FunctionMultiply">
<em class="property">static </em><code class="descname">FunctionMultiply</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.FunctionMultiply" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>PolesDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.FunctionReparameterise">
<em class="property">static </em><code class="descname">FunctionReparameterise</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.FunctionReparameterise" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>PolesDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.GetPole">
<em class="property">static </em><code class="descname">GetPole</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.GetPole" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Copy the pole at position &lt;Index&gt; in the Boor scheme of dimension &lt;Dimension&gt; to &lt;Position&gt; in the array &lt;Pole&gt;. &lt;Position&gt; is updated.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>LocPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Position</strong> (<em>int &amp;</em>) – </li>
<li><strong>Pole</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Hunt">
<em class="property">static </em><code class="descname">Hunt</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Hunt" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This routine searches the position of the real value X in the ordered set of real values XX. //! The elements in the table XX are either monotonically increasing or monotonically decreasing. //! The input value Iloc is used to initialize the algorithm : if Iloc is outside of the bounds [XX.Lower(), – XX.Upper()] the bisection algorithm is used else the routine searches from a previous known position by increasing steps then converges by bisection. //! This routine is used to locate a knot value in a set of knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>XX</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>X</strong> (<em>float</em>) – </li>
<li><strong>Iloc</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.IncreaseDegree">
<em class="property">static </em><code class="descname">IncreaseDegree</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.IncreaseDegree" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>NewDegree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>NewDegree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewDegree</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Increase the degree of a bspline (or bezier) curve of dimension &lt;Dimension&gt; form &lt;Degree&gt; to &lt;NewDegree&gt;. //! The number of poles in the new curve is : //! Poles.Length() + (NewDegree - Degree) * Number of spans //! Where the number of spans is : //! LastUKnotIndex(Mults) - FirstUKnotIndex(Mults) + 1 //! for a non-periodic curve //! And Knots.Length() - 1 for a periodic curve. //! The multiplicities of all knots are increased by the degree elevation. //! The new knots are usually the same knots with the exception of a non-periodic curve with the first and last multiplicity not equal to Degree+1 where knots are removed form the start and the bottom untils the sum of the multiplicities is equal to NewDegree+1 at the knots corresponding to the first and last parameters of the curve. //! Example : Suppose a curve of degree 3 starting with following knots and multiplicities : //! knot : 0. 1. 2. mult : 1 2 1 //! The FirstUKnot is 2. because the sum of multiplicities is Degree+1 : 1 + 2 + 1 = 4 = 3 + 1 //! i.e. the first parameter of the curve is 2. and will still be 2. after degree elevation. Let raises this curve to degree 4. The multiplicities are increased by 2. //! They become 2 3 2. But we need a sum of multiplicities of 5 at knot 2. So the first knot is removed and the new knots are : //! knot : 1. 2. mult : 3 2 //! The multipicity of the first knot may also be reduced if the sum is still to big. //! In the most common situations (periodic curve or curve with first and last multiplicities equals to Degree+1) the knots are knot changes. //! The method IncreaseDegreeCountKnots can be used to compute the new number of knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.IncreaseDegreeCountKnots">
<em class="property">static </em><code class="descname">IncreaseDegreeCountKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.IncreaseDegreeCountKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the number of knots of a curve with multiplicities &lt;Mults&gt; after elevating the degree from &lt;Degree&gt; to &lt;NewDegree&gt;. See the IncreaseDegree method for more comments.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.InsertKnot">
<em class="property">static </em><code class="descname">InsertKnot</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.InsertKnot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>UMult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Insert a new knot U of multiplicity UMult in the knot sequence. //! The location of the new Knot should be given as an input data. UIndex locates the new knot U in the knot sequence and Knots (UIndex) &lt; U &lt; Knots (UIndex + 1). //! The new control points corresponding to this insertion are returned. Knots and Mults are not updated.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>UMult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.InsertKnots">
<em class="property">static </em><code class="descname">InsertKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.InsertKnots" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>AddKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>AddMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – </li>
<li><strong>Add</strong> (<em>bool</em>) – default value is Standard_True</li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>AddKnots</strong> – </li>
<li><strong>AddMults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>Epsilon</strong> – </li>
<li><strong>Add</strong> – default value is Standard_True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Insert a sequence of knots &lt;AddKnots&gt; with multiplicities &lt;AddMults&gt;. &lt;AddKnots&gt; must be a non decreasing sequence and verifies : //! Knots(Knots.Lower()) &lt;= AddKnots(AddKnots.Lower()) Knots(Knots.Upper()) &gt;= AddKnots(AddKnots.Upper()) //! The NewPoles and NewWeights arrays must have a length : Poles.Length() + Sum(AddMults()) //! When a knot to insert is identic to an existing knot the multiplicities are added. //! Epsilon is used to test knots for equality. //! When AddMult is negative or null the knot is not inserted. No multiplicity will becomes higher than the degree. //! The new Knots and Multiplicities are copied in &lt;NewKnots&gt; and &lt;NewMults&gt;. //! All the New arrays should be correctly dimensioned. //! When all the new knots are existing knots, i.e. only the multiplicities will change it is safe to use the same arrays as input and output.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>AddKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>AddMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – </li>
<li><strong>Add</strong> (<em>bool</em>) – default value is Standard_True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Interpolate">
<em class="property">static </em><code class="descname">Interpolate</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the i</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray The length of FlatKnots is Degree + L + 1 The PolesArray is an seen as an Array[1..N][1..ArrayDimension] with N = tge length of the parameters array Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>FlatKnots</strong> – </li>
<li><strong>Parameters</strong> – </li>
<li><strong>ContactOrderArray</strong> – </li>
<li><strong>ArrayDimension</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>float &amp;</em>) – </li>
<li><strong>InversionProblem</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.IsRational">
<em class="property">static </em><code class="descname">IsRational</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.IsRational" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns False if all the weights of the array &lt;Weights&gt; between I1 an I2 are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>I1</strong> (<em>int</em>) – </li>
<li><strong>I2</strong> (<em>int</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – default value is 0.0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.KnotAnalysis">
<em class="property">static </em><code class="descname">KnotAnalysis</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.KnotAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Analyzes the array of knots. Returns the form and the maximum knot multiplicity.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>CKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>KnotForm</strong> (<em>GeomAbs_BSplKnotDistribution &amp;</em>) – </li>
<li><strong>MaxKnotMult</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.KnotForm">
<em class="property">static </em><code class="descname">KnotForm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.KnotForm" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Analyses if the knots distribution is ‘Uniform’ or ‘NonUniform’ between the knot FromK1 and the knot ToK2. There is no repetition of knot in the knots’sequence &lt;Knots&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">BSplCLib_KnotDistribution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.KnotSequence">
<em class="property">static </em><code class="descname">KnotSequence</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.KnotSequence" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Computes the sequence of knots KnotSeq with repetition of the knots of multiplicity greater than 1. //! Length of KnotSeq must be KnotSequenceLength(Mults,Degree,Periodic)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.KnotSequenceLength">
<em class="property">static </em><code class="descname">KnotSequenceLength</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.KnotSequenceLength" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the length of the sequence of knots with repetition. //! Periodic : //! Sum(Mults(i), i = Mults.Lower(); i &lt;= Mults.Upper()); //! Non Periodic : //! Sum(Mults(i); i = Mults.Lower(); i &lt; Mults.Upper()) + 2 * Degree</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Knots">
<em class="property">static </em><code class="descname">Knots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Knots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the sequence of knots Knots without repetition of the knots of multiplicity greater than 1. //! Length of &lt;Knots&gt; and &lt;Mults&gt; must be KnotsLength(KnotSequence,Periodic)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.KnotsLength">
<em class="property">static </em><code class="descname">KnotsLength</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.KnotsLength" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the length of the sequence of knots (and Mults) without repetition.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.LastUKnotIndex">
<em class="property">static </em><code class="descname">LastUKnotIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.LastUKnotIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the index of the knots value which gives the end point of the curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.LocateParameter">
<em class="property">static </em><code class="descname">LocateParameter</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.LocateParameter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) &lt;= U &lt; Knots(Index + 1) if U &lt;= Knots (K1) then Index = K1 if U &gt;= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be ‘withe repetitions’</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>IsPeriodic</strong> (<em>bool</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
<li><strong>KnotIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewU</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) &lt;= U &lt; Knots(Index + 1) if U &lt;= Knots (K1) then Index = K1 if U &gt;= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be ‘flat’</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>IsPeriodic</strong> (<em>bool</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
<li><strong>KnotIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewU</strong> (<em>float &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Index</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewU</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MaxDegree">
<em class="property">static </em><code class="descname">MaxDegree</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MaxDegree" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>returns the degree maxima for a BSplineCurve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MaxKnotMult">
<em class="property">static </em><code class="descname">MaxKnotMult</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MaxKnotMult" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Finds the greatest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>K1</strong> (<em>int</em>) – </li>
<li><strong>K2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MergeBSplineKnots">
<em class="property">static </em><code class="descname">MergeBSplineKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MergeBSplineKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Merges two knot vector by setting the starting and ending values to StartValue and EndValue</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>StartValue</strong> (<em>float</em>) – </li>
<li><strong>EndValue</strong> (<em>float</em>) – </li>
<li><strong>Degree1</strong> (<em>int</em>) – </li>
<li><strong>Knots1</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults1</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree2</strong> (<em>int</em>) – </li>
<li><strong>Knots2</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults2</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NumPoles</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>Handle_TColStd_HArray1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>Handle_TColStd_HArray1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MinKnotMult">
<em class="property">static </em><code class="descname">MinKnotMult</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MinKnotMult" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Finds the lowest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>K1</strong> (<em>int</em>) – </li>
<li><strong>K2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MovePoint">
<em class="property">static </em><code class="descname">MovePoint</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MovePoint" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -&gt; no constraint for one side don’t enter (1,NbPoles) -&gt; error: rigid move (2, NbPoles-1) -&gt; the ends are enforced (3, NbPoles-2) -&gt; the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Displ</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Index1</strong> (<em>int</em>) – </li>
<li><strong>Index2</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FirstIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>LastIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -&gt; no constraint for one side don’t enter (1,NbPoles) -&gt; error: rigid move (2, NbPoles-1) -&gt; the ends are enforced (3, NbPoles-2) -&gt; the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Displ</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Index1</strong> (<em>int</em>) – </li>
<li><strong>Index2</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FirstIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>LastIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MovePointAndTangent">
<em class="property">static </em><code class="descname">MovePointAndTangent</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MovePointAndTangent" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = … Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Delta</strong> (<em>float &amp;</em>) – </li>
<li><strong>DeltaDerivative</strong> (<em>float &amp;</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>StartingCondition</strong> (<em>int</em>) – </li>
<li><strong>EndingCondition</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>ErrorStatus</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = … Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Delta</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>DeltaDerivative</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>StartingCondition</strong> (<em>int</em>) – </li>
<li><strong>EndingCondition</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>ErrorStatus</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = … Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Delta</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>DeltaDerivative</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>StartingCondition</strong> (<em>int</em>) – </li>
<li><strong>EndingCondition</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>ErrorStatus</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.MultForm">
<em class="property">static </em><code class="descname">MultForm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.MultForm" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Analyses the distribution of multiplicities between the knot FromK1 and the Knot ToK2.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">BSplCLib_MultDistribution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.NbPoles">
<em class="property">static </em><code class="descname">NbPoles</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.NbPoles" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the number of poles of the curve. Returns 0 if one of the multiplicities is incorrect. //! * Non positive. //! * Greater than Degree, or Degree+1 at the first and last knot of a non periodic curve. //! * The last periodicity on a periodic curve is not equal to the first.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.NoMults">
<em class="property">static </em><code class="descname">NoMults</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.NoMults" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Used as argument for a flatknots evaluation.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="OCC.TColStd.html#OCC.TColStd.TColStd_Array1OfInteger" title="OCC.TColStd.TColStd_Array1OfInteger">TColStd_Array1OfInteger</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.NoWeights">
<em class="property">static </em><code class="descname">NoWeights</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.NoWeights" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Used as argument for a non rational curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="OCC.TColStd.html#OCC.TColStd.TColStd_Array1OfReal" title="OCC.TColStd.TColStd_Array1OfReal">TColStd_Array1OfReal</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.PoleIndex">
<em class="property">static </em><code class="descname">PoleIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.PoleIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Return the index of the first Pole to use on the span Mults(Index) - Mults(Index+1). This index must be added to Poles.Lower().</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.PolesCoefficients">
<em class="property">static </em><code class="descname">PolesCoefficients</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.PolesCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> – </li>
<li><strong>CachePoles</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziercurves at parameter 0. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.PrepareInsertKnots">
<em class="property">static </em><code class="descname">PrepareInsertKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.PrepareInsertKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns in &lt;NbPoles, NbKnots&gt; the new number of poles and knots if the sequence of knots &lt;AddKnots, AddMults&gt; is inserted in the sequence &lt;Knots, Mults&gt;. //! Epsilon is used to compare knots for equality. //! If Add is True the multiplicities on equal knots are added. //! If Add is False the max value of the multiplicities is kept. //! Return False if : The knew knots are knot increasing. The new knots are not in the range.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>AddKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>AddMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NbPoles</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbKnots</strong> (<em>int &amp;</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – </li>
<li><strong>Add</strong> (<em>bool</em>) – default value is Standard_True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.PrepareTrimming">
<em class="property">static </em><code class="descname">PrepareTrimming</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.PrepareTrimming" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set in &lt;NbKnots&gt; and &lt;NbPoles&gt; the number of Knots and Poles of the curve resulting of the trimming of the BSplinecurve definded with &lt;degree&gt;, &lt;knots&gt;, &lt;mults&gt;</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>U1</strong> (<em>float</em>) – </li>
<li><strong>U2</strong> (<em>float</em>) – </li>
<li><strong>NbKnots</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbPoles</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.PrepareUnperiodize">
<em class="property">static </em><code class="descname">PrepareUnperiodize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.PrepareUnperiodize" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set in &lt;NbKnots&gt; and &lt;NbPolesToAdd&gt; the number of Knots and Poles of the NotPeriodic Curve identical at the periodic curve with a degree &lt;Degree&gt; , a knots-distribution with Multiplicities &lt;Mults&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NbKnots</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbPoles</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.RaiseMultiplicity">
<em class="property">static </em><code class="descname">RaiseMultiplicity</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.RaiseMultiplicity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotIndex</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Raise the multiplicity of knot to &lt;UMult&gt;. //! The new control points are returned. Knots and Mults are not updated.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotIndex</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.RemoveKnot">
<em class="property">static </em><code class="descname">RemoveKnot</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.RemoveKnot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> – </li>
<li><strong>Mult</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>Tolerance</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">bool</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Decrement the multiplicity of &lt;Knots(Index)&gt; to &lt;Mult&gt;. If &lt;Mult&gt; is null the knot is removed. //! As there are two ways to compute the new poles the midlle will be used as long as the distance is lower than Tolerance. //! If a distance is bigger than tolerance the methods returns False and the new arrays are not modified. //! A low tolerance can be used to test if the knot can be removed without modifying the curve. //! A high tolerance can be used to ‘smooth’ the curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Reparametrize">
<em class="property">static </em><code class="descname">Reparametrize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Reparametrize" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Reparametrizes a B-spline curve to [U1, U2]. The knot values are recomputed such that Knots (Lower) = U1 and Knots (Upper) = U2 but the knot form is not modified. Warnings : In the array Knots the values must be in ascending order. U1 must not be equal to U2 to avoid division by zero.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U1</strong> (<em>float</em>) – </li>
<li><strong>U2</strong> (<em>float</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Resolution">
<em class="property">static </em><code class="descname">Resolution</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Resolution" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | &lt; UTolerance and we have <a href="#id1"><span class="problematic" id="id2">|f (u1) - f (u0)|</span></a> &lt; Tolerance3D</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>PolesArray</strong> (<em>float &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Tolerance3D</strong> (<em>float</em>) – </li>
<li><strong>UTolerance</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | &lt; UTolerance and we have <a href="#id3"><span class="problematic" id="id4">|f (u1) - f (u0)|</span></a> &lt; Tolerance3D</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Tolerance3D</strong> (<em>float</em>) – </li>
<li><strong>UTolerance</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | &lt; UTolerance and we have <a href="#id5"><span class="problematic" id="id6">|f (u1) - f (u0)|</span></a> &lt; Tolerance3D</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Tolerance3D</strong> (<em>float</em>) – </li>
<li><strong>UTolerance</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Reverse">
<em class="property">static </em><code class="descname">Reverse</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Reverse" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Reverses the array knots to become the knots sequence of the reversed curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">void</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of multiplicities.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">void</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of poles. Last is the index of the new first pole. On a non periodic curve last is Poles.Upper(). On a periodic curve last is //! (number of flat knots - degree - 1) //! or //! (sum of multiplicities(but for the last) + degree - 1)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Last</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of poles.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Last</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of poles.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Last</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.SolveBandedSystem">
<em class="property">static </em><code class="descname">SolveBandedSystem</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.SolveBandedSystem" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> (<em>float &amp;</em>) – </li>
<li><strong>Matrix</strong> – </li>
<li><strong>UpperBandWidth</strong> – </li>
<li><strong>LowerBandWidth</strong> – </li>
<li><strong>HomogenousFlag</strong> (<em>bool</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> – </li>
<li><strong>Weights</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension. If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>HomogenousFlag</strong> (<em>bool</em>) – </li>
<li><strong>Array</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>HomogeneousFlag</strong> (<em>bool</em>) – </li>
<li><strong>Array</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.TangExtendToConstraint">
<em class="property">static </em><code class="descname">TangExtendToConstraint</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.TangExtendToConstraint" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Extend a BSpline nD using the tangency map &lt;C1Coefficient&gt; is the coefficient of reparametrisation &lt;Continuity&gt; must be equal to 1, 2 or 3. &lt;Degree&gt; must be greater or equal than &lt;Continuity&gt; + 1. //! Warning: &lt;KnotsResult&gt; and &lt;PolesResult&gt; must be dimensionned properly.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>C1Coefficient</strong> (<em>float</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>ConstraintPoint</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Continuity</strong> (<em>int</em>) – </li>
<li><strong>After</strong> (<em>bool</em>) – </li>
<li><strong>NbPolesResult</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbKnotsRsult</strong> (<em>int &amp;</em>) – </li>
<li><strong>KnotsResult</strong> (<em>float &amp;</em>) – </li>
<li><strong>PolesResult</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Trimming">
<em class="property">static </em><code class="descname">Trimming</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Trimming" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>U1</strong> (<em>float</em>) – </li>
<li><strong>U2</strong> (<em>float</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>U1</strong> – </li>
<li><strong>U2</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>U1</strong> – </li>
<li><strong>U2</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="OCC.BSplCLib.bsplclib.Unperiodize">
<em class="property">static </em><code class="descname">Unperiodize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib.Unperiodize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="OCC.BSplCLib.bsplclib.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#OCC.BSplCLib.bsplclib.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_AntiBoorScheme">
<code class="descname">bsplclib_AntiBoorScheme</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_AntiBoorScheme" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Compute the content of Pole before the BoorScheme. This method is used to remove poles. //! U is the poles to remove, Knots should contains the knots of the curve after knot removal. //! The first and last poles do not change, the other poles are computed by averaging two possible values. The distance between the two possible poles is computed, if it is higher than &lt;Tolerance&gt; False is returned.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Bohm">
<code class="descname">bsplclib_Bohm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Bohm" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Performs the Bohm Algorithm at parameter &lt;U&gt;. This algorithm computes the value and all the derivatives up to order N (N &lt;= Degree). //! &lt;Poles&gt; is the original array of poles. //! The result in &lt;Poles&gt; is the value and the derivatives. Poles[0] is the value, Poles[Degree] is the last derivative.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>N</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BoorIndex">
<code class="descname">bsplclib_BoorIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BoorIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the index in the Boor result array of the poles &lt;Index&gt;. If the Boor algorithm was perform with &lt;Length&gt; and &lt;Depth&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BoorScheme">
<code class="descname">bsplclib_BoorScheme</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BoorScheme" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Performs the Boor Algorithm at parameter &lt;U&gt; with the given &lt;Degree&gt; and the array of &lt;Knots&gt; on the poles &lt;Poles&gt; of dimension &lt;Dimension&gt;. The schema is computed until level &lt;Depth&gt; on a basis of &lt;Length+1&gt; poles. //! * Knots is an array of reals of length : //! &lt;Length&gt; + &lt;Degree&gt; //! * Poles is an array of reals of length : //! (2 * &lt;Length&gt; + 1) * &lt;Dimension&gt; //! The poles values must be set in the array at the positions. //! 0..Dimension, //! 2 * Dimension .. 3 * Dimension //! 4 * Dimension .. 5 * Dimension //! … //! The results are found in the array poles depending on the Depth. (See the method GetPole).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BuildBSpMatrix">
<code class="descname">bsplclib_BuildBSpMatrix</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BuildBSpMatrix" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This Builds a fully blown Matrix of (ni) Bi (tj) //! with i and j within 1..Order + NumPoles The integer ni is the ith slot of the array OrderArray, tj is the jth slot of the array Parameters</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>OrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int &amp;</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BuildBoor">
<code class="descname">bsplclib_BuildBoor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BuildBoor" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Copy in &lt;LP&gt; poles for &lt;Dimension&gt; Boor scheme. Starting from &lt;Index&gt; * &lt;Dimension&gt;, copy &lt;Length+1&gt; poles.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>LP</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BuildCache">
<code class="descname">bsplclib_BuildCache</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BuildCache" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>InverseOfSpanDomain</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>InverseOfSpanDomain</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BuildEval">
<code class="descname">bsplclib_BuildEval</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BuildEval" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>LP</strong> (<em>float &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>LP</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Copy in &lt;LP&gt; the poles and weights for the Eval scheme. starting from Poles(Poles.Lower()+Index)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>LP</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BuildKnots">
<code class="descname">bsplclib_BuildKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BuildKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Stores in LK the usefull knots for the BoorSchem on the span Knots(Index) - Knots(Index+1)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>LK</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_BuildSchoenbergPoints">
<code class="descname">bsplclib_BuildSchoenbergPoints</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_BuildSchoenbergPoints" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>builds the Schoenberg points from the flat knot used to interpolate a BSpline since the BSpline matrix is invertible.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CacheD0">
<code class="descname">bsplclib_CacheD0</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CacheD0" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CacheD1">
<code class="descname">bsplclib_CacheD1</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CacheD1" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CacheD2">
<code class="descname">bsplclib_CacheD2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CacheD2" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CacheD3">
<code class="descname">bsplclib_CacheD3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CacheD3" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>CacheParameter</strong> (<em>float</em>) – </li>
<li><strong>SpanLenght</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CoefsD0">
<code class="descname">bsplclib_CoefsD0</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CoefsD0" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CoefsD1">
<code class="descname">bsplclib_CoefsD1</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CoefsD1" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CoefsD2">
<code class="descname">bsplclib_CoefsD2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CoefsD2" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_CoefsD3">
<code class="descname">bsplclib_CoefsD3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_CoefsD3" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Vec1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Vec3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_D0">
<code class="descname">bsplclib_D0</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_D0" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_D1">
<code class="descname">bsplclib_D1</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_D1" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>V</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_D2">
<code class="descname">bsplclib_D2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_D2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>V1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>V2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_D3">
<code class="descname">bsplclib_D3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_D3" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>P</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>V1</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>V2</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>V3</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Index</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
<li><strong>U</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>P</strong> – </li>
<li><strong>V1</strong> – </li>
<li><strong>V2</strong> – </li>
<li><strong>V3</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Derivative">
<code class="descname">bsplclib_Derivative</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Derivative" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the poles of the BSpline giving the derivatives of order &lt;Order&gt;. //! The formula for the first order is //! Pole(i) = Degree * (Pole(i+1) - Pole(i)) / (Knots(i+Degree+1) - Knots(i+1)) //! This formula is repeated (Degree is decremented at each step).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Order</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Eval">
<code class="descname">bsplclib_Eval</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Eval" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Perform the Boor algorithm to evaluate a point at parameter &lt;U&gt;, with &lt;Degree&gt; and &lt;Dimension&gt;. //! Poles is an array of Reals of size //! &lt;Dimension&gt; * &lt;Degree&gt;+1 //! Containing the poles. At the end &lt;Poles&gt; contains the current point.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the De Boor algorithm to evaluate a point at parameter &lt;U&gt;, with &lt;Degree&gt; and &lt;Dimension&gt;. //! Poles is an array of Reals of size //! &lt;Dimension&gt; * &lt;Degree&gt;+1 //! Containing the poles. At the end &lt;Poles&gt; contains the current point. Poles Contain all the poles of the BsplineCurve, Knots also Contains all the knots of the BsplineCurve. ExtrapMode has two slots [0] = Degree used to extrapolate before the first knot [1] = Degre used to extrapolate after the last knot has to be between 1 and Degree</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>DerivativeRequest</strong> (<em>int</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Result</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the De Boor algorithm to evaluate a point at parameter &lt;U&gt;, with &lt;Degree&gt; and &lt;Dimension&gt;. Evaluates by multiplying the Poles by the Weights and gives the homogeneous result in PolesResult that is the results of the evaluation of the numerator once it has been multiplied by the weights and in WeightsResult one has the result of the evaluation of the denominator //! Warning: &lt;PolesResult&gt; and &lt;WeightsResult&gt; must be dimensionned properly.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>DerivativeRequest</strong> (<em>int</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Weights</strong> (<em>float &amp;</em>) – </li>
<li><strong>PolesResult</strong> (<em>float &amp;</em>) – </li>
<li><strong>WeightsResult</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>HomogeneousFlag</strong> (<em>bool</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt" title="OCC.gp.gp_Pnt"><em>gp_Pnt</em></a>) – </li>
<li><strong>Weight</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>PeriodicFlag</strong> (<em>bool</em>) – </li>
<li><strong>HomogeneousFlag</strong> (<em>bool</em>) – </li>
<li><strong>ExtrapMode</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Point</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Pnt2d" title="OCC.gp.gp_Pnt2d"><em>gp_Pnt2d</em></a>) – </li>
<li><strong>Weight</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_EvalBsplineBasis">
<code class="descname">bsplclib_EvalBsplineBasis</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_EvalBsplineBasis" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This evaluates the Bspline Basis at a given parameter Parameter up to the requested DerivativeOrder and store the result in the array BsplineBasis in the following fashion BSplineBasis(1,1) = value of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BsplineBasis(1,2) = value of second non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + 1 BsplineBasis(1,n) = value of second non vanishing non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + n (n &lt;= Order) BSplineBasis(2,1) = value of derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BSplineBasis(N,1) = value of Nth derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex if N &lt;= DerivativeOrder + 1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Side</strong> (<em>int</em>) – </li>
<li><strong>DerivativeOrder</strong> (<em>int</em>) – </li>
<li><strong>Order</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameter</strong> (<em>float</em>) – </li>
<li><strong>FirstNonZeroBsplineIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>BsplineBasis</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>isPeriodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_FactorBandedMatrix">
<code class="descname">bsplclib_FactorBandedMatrix</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_FactorBandedMatrix" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>this factors the Banded Matrix in the LU form with a Banded storage of components of the L matrix WARNING : do not use if the Matrix is totally positive (It is the case for Bspline matrices build as above with parameters being the Schoenberg points</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>PivotIndexProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_FirstUKnotIndex">
<code class="descname">bsplclib_FirstUKnotIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_FirstUKnotIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the index of the knots value which gives the start point of the curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_FlatBezierKnots">
<code class="descname">bsplclib_FlatBezierKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_FlatBezierKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns pointer to statically allocated array representing flat knots for bezier curve of the specified degree. Raises OutOfRange if Degree &gt; MaxDegree()</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Degree</strong> (<em>int</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_FlatIndex">
<code class="descname">bsplclib_FlatIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_FlatIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the index of the flats knots sequence corresponding to &lt;Index&gt; in the knots sequence which multiplicities are &lt;Mults&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_FunctionMultiply">
<code class="descname">bsplclib_FunctionMultiply</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_FunctionMultiply" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>PolesDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_FunctionReparameterise">
<code class="descname">bsplclib_FunctionReparameterise</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_FunctionReparameterise" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>PolesDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller’s responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Function</strong> (<em>BSplCLib_EvaluatorFunction &amp;</em>) – </li>
<li><strong>BSplineDegree</strong> (<em>int</em>) – </li>
<li><strong>BSplineFlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Status</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_GetPole">
<code class="descname">bsplclib_GetPole</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_GetPole" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Copy the pole at position &lt;Index&gt; in the Boor scheme of dimension &lt;Dimension&gt; to &lt;Position&gt; in the array &lt;Pole&gt;. &lt;Position&gt; is updated.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Length</strong> (<em>int</em>) – </li>
<li><strong>Depth</strong> (<em>int</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>LocPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Position</strong> (<em>int &amp;</em>) – </li>
<li><strong>Pole</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Hunt">
<code class="descname">bsplclib_Hunt</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Hunt" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This routine searches the position of the real value X in the ordered set of real values XX. //! The elements in the table XX are either monotonically increasing or monotonically decreasing. //! The input value Iloc is used to initialize the algorithm : if Iloc is outside of the bounds [XX.Lower(), – XX.Upper()] the bisection algorithm is used else the routine searches from a previous known position by increasing steps then converges by bisection. //! This routine is used to locate a knot value in a set of knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>XX</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>X</strong> (<em>float</em>) – </li>
<li><strong>Iloc</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_IncreaseDegree">
<code class="descname">bsplclib_IncreaseDegree</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_IncreaseDegree" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>NewDegree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>NewDegree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewDegree</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Increase the degree of a bspline (or bezier) curve of dimension &lt;Dimension&gt; form &lt;Degree&gt; to &lt;NewDegree&gt;. //! The number of poles in the new curve is : //! Poles.Length() + (NewDegree - Degree) * Number of spans //! Where the number of spans is : //! LastUKnotIndex(Mults) - FirstUKnotIndex(Mults) + 1 //! for a non-periodic curve //! And Knots.Length() - 1 for a periodic curve. //! The multiplicities of all knots are increased by the degree elevation. //! The new knots are usually the same knots with the exception of a non-periodic curve with the first and last multiplicity not equal to Degree+1 where knots are removed form the start and the bottom untils the sum of the multiplicities is equal to NewDegree+1 at the knots corresponding to the first and last parameters of the curve. //! Example : Suppose a curve of degree 3 starting with following knots and multiplicities : //! knot : 0. 1. 2. mult : 1 2 1 //! The FirstUKnot is 2. because the sum of multiplicities is Degree+1 : 1 + 2 + 1 = 4 = 3 + 1 //! i.e. the first parameter of the curve is 2. and will still be 2. after degree elevation. Let raises this curve to degree 4. The multiplicities are increased by 2. //! They become 2 3 2. But we need a sum of multiplicities of 5 at knot 2. So the first knot is removed and the new knots are : //! knot : 1. 2. mult : 3 2 //! The multipicity of the first knot may also be reduced if the sum is still to big. //! In the most common situations (periodic curve or curve with first and last multiplicities equals to Degree+1) the knots are knot changes. //! The method IncreaseDegreeCountKnots can be used to compute the new number of knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_IncreaseDegreeCountKnots">
<code class="descname">bsplclib_IncreaseDegreeCountKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_IncreaseDegreeCountKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the number of knots of a curve with multiplicities &lt;Mults&gt; after elevating the degree from &lt;Degree&gt; to &lt;NewDegree&gt;. See the IncreaseDegree method for more comments.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>NewDegree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_InsertKnot">
<code class="descname">bsplclib_InsertKnot</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_InsertKnot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>UMult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Insert a new knot U of multiplicity UMult in the knot sequence. //! The location of the new Knot should be given as an input data. UIndex locates the new knot U in the knot sequence and Knots (UIndex) &lt; U &lt; Knots (UIndex + 1). //! The new control points corresponding to this insertion are returned. Knots and Mults are not updated.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>UIndex</strong> (<em>int</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>UMult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_InsertKnots">
<code class="descname">bsplclib_InsertKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_InsertKnots" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>AddKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>AddMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – </li>
<li><strong>Add</strong> (<em>bool</em>) – default value is Standard_True</li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>AddKnots</strong> – </li>
<li><strong>AddMults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>Epsilon</strong> – </li>
<li><strong>Add</strong> – default value is Standard_True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Insert a sequence of knots &lt;AddKnots&gt; with multiplicities &lt;AddMults&gt;. &lt;AddKnots&gt; must be a non decreasing sequence and verifies : //! Knots(Knots.Lower()) &lt;= AddKnots(AddKnots.Lower()) Knots(Knots.Upper()) &gt;= AddKnots(AddKnots.Upper()) //! The NewPoles and NewWeights arrays must have a length : Poles.Length() + Sum(AddMults()) //! When a knot to insert is identic to an existing knot the multiplicities are added. //! Epsilon is used to test knots for equality. //! When AddMult is negative or null the knot is not inserted. No multiplicity will becomes higher than the degree. //! The new Knots and Multiplicities are copied in &lt;NewKnots&gt; and &lt;NewMults&gt;. //! All the New arrays should be correctly dimensioned. //! When all the new knots are existing knots, i.e. only the multiplicities will change it is safe to use the same arrays as input and output.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>AddKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>AddMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – </li>
<li><strong>Add</strong> (<em>bool</em>) – default value is Standard_True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Interpolate">
<code class="descname">bsplclib_Interpolate</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the i</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray The length of FlatKnots is Degree + L + 1 The PolesArray is an seen as an Array[1..N][1..ArrayDimension] with N = tge length of the parameters array Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Parameters</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>ContactOrderArray</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>InversionProblem</strong> (<em>int &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>FlatKnots</strong> – </li>
<li><strong>Parameters</strong> – </li>
<li><strong>ContactOrderArray</strong> – </li>
<li><strong>ArrayDimension</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>float &amp;</em>) – </li>
<li><strong>InversionProblem</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_IsRational">
<code class="descname">bsplclib_IsRational</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_IsRational" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns False if all the weights of the array &lt;Weights&gt; between I1 an I2 are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>I1</strong> (<em>int</em>) – </li>
<li><strong>I2</strong> (<em>int</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – default value is 0.0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_KnotAnalysis">
<code class="descname">bsplclib_KnotAnalysis</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_KnotAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Analyzes the array of knots. Returns the form and the maximum knot multiplicity.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>CKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>KnotForm</strong> (<em>GeomAbs_BSplKnotDistribution &amp;</em>) – </li>
<li><strong>MaxKnotMult</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_KnotForm">
<code class="descname">bsplclib_KnotForm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_KnotForm" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Analyses if the knots distribution is ‘Uniform’ or ‘NonUniform’ between the knot FromK1 and the knot ToK2. There is no repetition of knot in the knots’sequence &lt;Knots&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">BSplCLib_KnotDistribution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_KnotSequence">
<code class="descname">bsplclib_KnotSequence</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_KnotSequence" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Computes the sequence of knots KnotSeq with repetition of the knots of multiplicity greater than 1. //! Length of KnotSeq must be KnotSequenceLength(Mults,Degree,Periodic)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_KnotSequenceLength">
<code class="descname">bsplclib_KnotSequenceLength</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_KnotSequenceLength" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the length of the sequence of knots with repetition. //! Periodic : //! Sum(Mults(i), i = Mults.Lower(); i &lt;= Mults.Upper()); //! Non Periodic : //! Sum(Mults(i); i = Mults.Lower(); i &lt; Mults.Upper()) + 2 * Degree</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Knots">
<code class="descname">bsplclib_Knots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Knots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the sequence of knots Knots without repetition of the knots of multiplicity greater than 1. //! Length of &lt;Knots&gt; and &lt;Mults&gt; must be KnotsLength(KnotSequence,Periodic)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_KnotsLength">
<code class="descname">bsplclib_KnotsLength</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_KnotsLength" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the length of the sequence of knots (and Mults) without repetition.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotSeq</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – default value is Standard_False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_LastUKnotIndex">
<code class="descname">bsplclib_LastUKnotIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_LastUKnotIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Computes the index of the knots value which gives the end point of the curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_LocateParameter">
<code class="descname">bsplclib_LocateParameter</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_LocateParameter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) &lt;= U &lt; Knots(Index + 1) if U &lt;= Knots (K1) then Index = K1 if U &gt;= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be ‘withe repetitions’</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>IsPeriodic</strong> (<em>bool</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
<li><strong>KnotIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewU</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) &lt;= U &lt; Knots(Index + 1) if U &lt;= Knots (K1) then Index = K1 if U &gt;= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be ‘flat’</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>IsPeriodic</strong> (<em>bool</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
<li><strong>KnotIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewU</strong> (<em>float &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>U</strong> – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Index</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewU</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MaxDegree">
<code class="descname">bsplclib_MaxDegree</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MaxDegree" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>returns the degree maxima for a BSplineCurve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MaxKnotMult">
<code class="descname">bsplclib_MaxKnotMult</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MaxKnotMult" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Finds the greatest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>K1</strong> (<em>int</em>) – </li>
<li><strong>K2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MergeBSplineKnots">
<code class="descname">bsplclib_MergeBSplineKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MergeBSplineKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Merges two knot vector by setting the starting and ending values to StartValue and EndValue</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>StartValue</strong> (<em>float</em>) – </li>
<li><strong>EndValue</strong> (<em>float</em>) – </li>
<li><strong>Degree1</strong> (<em>int</em>) – </li>
<li><strong>Knots1</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults1</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Degree2</strong> (<em>int</em>) – </li>
<li><strong>Knots2</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults2</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NumPoles</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>Handle_TColStd_HArray1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>Handle_TColStd_HArray1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MinKnotMult">
<code class="descname">bsplclib_MinKnotMult</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MinKnotMult" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Finds the lowest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>K1</strong> (<em>int</em>) – </li>
<li><strong>K2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MovePoint">
<code class="descname">bsplclib_MovePoint</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MovePoint" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -&gt; no constraint for one side don’t enter (1,NbPoles) -&gt; error: rigid move (2, NbPoles-1) -&gt; the ends are enforced (3, NbPoles-2) -&gt; the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Displ</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Index1</strong> (<em>int</em>) – </li>
<li><strong>Index2</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FirstIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>LastIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -&gt; no constraint for one side don’t enter (1,NbPoles) -&gt; error: rigid move (2, NbPoles-1) -&gt; the ends are enforced (3, NbPoles-2) -&gt; the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Displ</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Index1</strong> (<em>int</em>) – </li>
<li><strong>Index2</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FirstIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>LastIndex</strong> (<em>int &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MovePointAndTangent">
<code class="descname">bsplclib_MovePointAndTangent</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MovePointAndTangent" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = … Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Delta</strong> (<em>float &amp;</em>) – </li>
<li><strong>DeltaDerivative</strong> (<em>float &amp;</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>StartingCondition</strong> (<em>int</em>) – </li>
<li><strong>EndingCondition</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<em>float &amp;</em>) – </li>
<li><strong>ErrorStatus</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = … Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Delta</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>DeltaDerivative</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec" title="OCC.gp.gp_Vec"><em>gp_Vec</em></a>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>StartingCondition</strong> (<em>int</em>) – </li>
<li><strong>EndingCondition</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>ErrorStatus</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = … Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> (<em>float</em>) – </li>
<li><strong>Delta</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>DeltaDerivative</strong> (<a class="reference internal" href="OCC.gp.html#OCC.gp.gp_Vec2d" title="OCC.gp.gp_Vec2d"><em>gp_Vec2d</em></a>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Rational</strong> (<em>bool</em>) – </li>
<li><strong>StartingCondition</strong> (<em>int</em>) – </li>
<li><strong>EndingCondition</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>ErrorStatus</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_MultForm">
<code class="descname">bsplclib_MultForm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_MultForm" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Analyses the distribution of multiplicities between the knot FromK1 and the Knot ToK2.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>FromK1</strong> (<em>int</em>) – </li>
<li><strong>ToK2</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">BSplCLib_MultDistribution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_NbPoles">
<code class="descname">bsplclib_NbPoles</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_NbPoles" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the number of poles of the curve. Returns 0 if one of the multiplicities is incorrect. //! * Non positive. //! * Greater than Degree, or Degree+1 at the first and last knot of a non periodic curve. //! * The last periodicity on a periodic curve is not equal to the first.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_NoMults">
<code class="descname">bsplclib_NoMults</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_NoMults" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Used as argument for a flatknots evaluation.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="OCC.TColStd.html#OCC.TColStd.TColStd_Array1OfInteger" title="OCC.TColStd.TColStd_Array1OfInteger">TColStd_Array1OfInteger</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_NoWeights">
<code class="descname">bsplclib_NoWeights</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_NoWeights" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Used as argument for a non rational curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="OCC.TColStd.html#OCC.TColStd.TColStd_Array1OfReal" title="OCC.TColStd.TColStd_Array1OfReal">TColStd_Array1OfReal</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_PoleIndex">
<code class="descname">bsplclib_PoleIndex</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_PoleIndex" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Return the index of the first Pole to use on the span Mults(Index) - Mults(Index+1). This index must be added to Poles.Lower().</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_PolesCoefficients">
<code class="descname">bsplclib_PolesCoefficients</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_PolesCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> – </li>
<li><strong>CachePoles</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziercurves at parameter 0. Warning: To be used for Beziercurves ONLY!!!</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>CachePoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>CacheWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_PrepareInsertKnots">
<code class="descname">bsplclib_PrepareInsertKnots</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_PrepareInsertKnots" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns in &lt;NbPoles, NbKnots&gt; the new number of poles and knots if the sequence of knots &lt;AddKnots, AddMults&gt; is inserted in the sequence &lt;Knots, Mults&gt;. //! Epsilon is used to compare knots for equality. //! If Add is True the multiplicities on equal knots are added. //! If Add is False the max value of the multiplicities is kept. //! Return False if : The knew knots are knot increasing. The new knots are not in the range.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>AddKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>AddMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NbPoles</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbKnots</strong> (<em>int &amp;</em>) – </li>
<li><strong>Epsilon</strong> (<em>float</em>) – </li>
<li><strong>Add</strong> (<em>bool</em>) – default value is Standard_True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_PrepareTrimming">
<code class="descname">bsplclib_PrepareTrimming</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_PrepareTrimming" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set in &lt;NbKnots&gt; and &lt;NbPoles&gt; the number of Knots and Poles of the curve resulting of the trimming of the BSplinecurve definded with &lt;degree&gt;, &lt;knots&gt;, &lt;mults&gt;</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>U1</strong> (<em>float</em>) – </li>
<li><strong>U2</strong> (<em>float</em>) – </li>
<li><strong>NbKnots</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbPoles</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_PrepareUnperiodize">
<code class="descname">bsplclib_PrepareUnperiodize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_PrepareUnperiodize" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set in &lt;NbKnots&gt; and &lt;NbPolesToAdd&gt; the number of Knots and Poles of the NotPeriodic Curve identical at the periodic curve with a degree &lt;Degree&gt; , a knots-distribution with Multiplicities &lt;Mults&gt;.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NbKnots</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbPoles</strong> (<em>int &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_RaiseMultiplicity">
<code class="descname">bsplclib_RaiseMultiplicity</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_RaiseMultiplicity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotIndex</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Raise the multiplicity of knot to &lt;UMult&gt;. //! The new control points are returned. Knots and Mults are not updated.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>KnotIndex</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_RemoveKnot">
<code class="descname">bsplclib_RemoveKnot</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_RemoveKnot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
<li><strong>Index</strong> – </li>
<li><strong>Mult</strong> – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>Tolerance</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">bool</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Decrement the multiplicity of &lt;Knots(Index)&gt; to &lt;Mult&gt;. If &lt;Mult&gt; is null the knot is removed. //! As there are two ways to compute the new poles the midlle will be used as long as the distance is lower than Tolerance. //! If a distance is bigger than tolerance the methods returns False and the new arrays are not modified. //! A low tolerance can be used to test if the knot can be removed without modifying the curve. //! A high tolerance can be used to ‘smooth’ the curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Index</strong> (<em>int</em>) – </li>
<li><strong>Mult</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Tolerance</strong> (<em>float</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Reparametrize">
<code class="descname">bsplclib_Reparametrize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Reparametrize" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Reparametrizes a B-spline curve to [U1, U2]. The knot values are recomputed such that Knots (Lower) = U1 and Knots (Upper) = U2 but the knot form is not modified. Warnings : In the array Knots the values must be in ascending order. U1 must not be equal to U2 to avoid division by zero.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U1</strong> (<em>float</em>) – </li>
<li><strong>U2</strong> (<em>float</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Resolution">
<code class="descname">bsplclib_Resolution</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Resolution" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | &lt; UTolerance and we have <a href="#id7"><span class="problematic" id="id8">|f (u1) - f (u0)|</span></a> &lt; Tolerance3D</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>PolesArray</strong> (<em>float &amp;</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Tolerance3D</strong> (<em>float</em>) – </li>
<li><strong>UTolerance</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | &lt; UTolerance and we have <a href="#id9"><span class="problematic" id="id10">|f (u1) - f (u0)|</span></a> &lt; Tolerance3D</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Tolerance3D</strong> (<em>float</em>) – </li>
<li><strong>UTolerance</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | &lt; UTolerance and we have <a href="#id11"><span class="problematic" id="id12">|f (u1) - f (u0)|</span></a> &lt; Tolerance3D</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Tolerance3D</strong> (<em>float</em>) – </li>
<li><strong>UTolerance</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Reverse">
<code class="descname">bsplclib_Reverse</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Reverse" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Reverses the array knots to become the knots sequence of the reversed curve.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">void</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of multiplicities.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">void</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of poles. Last is the index of the new first pole. On a non periodic curve last is Poles.Upper(). On a periodic curve last is //! (number of flat knots - degree - 1) //! or //! (sum of multiplicities(but for the last) + degree - 1)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Last</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of poles.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Last</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Reverses the array of poles.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Last</strong> (<em>int</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_SolveBandedSystem">
<code class="descname">bsplclib_SolveBandedSystem</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_SolveBandedSystem" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> (<em>float &amp;</em>) – </li>
<li><strong>Matrix</strong> – </li>
<li><strong>UpperBandWidth</strong> – </li>
<li><strong>LowerBandWidth</strong> – </li>
<li><strong>HomogenousFlag</strong> (<em>bool</em>) – </li>
<li><strong>ArrayDimension</strong> (<em>int</em>) – </li>
<li><strong>Array</strong> – </li>
<li><strong>Weights</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension. If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>HomogenousFlag</strong> (<em>bool</em>) – </li>
<li><strong>Array</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Matrix</strong> (<em>math_Matrix &amp;</em>) – </li>
<li><strong>UpperBandWidth</strong> (<em>int</em>) – </li>
<li><strong>LowerBandWidth</strong> (<em>int</em>) – </li>
<li><strong>HomogeneousFlag</strong> (<em>bool</em>) – </li>
<li><strong>Array</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt" title="OCC.TColgp.TColgp_Array1OfPnt"><em>TColgp_Array1OfPnt</em></a>) – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_TangExtendToConstraint">
<code class="descname">bsplclib_TangExtendToConstraint</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_TangExtendToConstraint" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Extend a BSpline nD using the tangency map &lt;C1Coefficient&gt; is the coefficient of reparametrisation &lt;Continuity&gt; must be equal to 1, 2 or 3. &lt;Degree&gt; must be greater or equal than &lt;Continuity&gt; + 1. //! Warning: &lt;KnotsResult&gt; and &lt;PolesResult&gt; must be dimensionned properly.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>FlatKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>C1Coefficient</strong> (<em>float</em>) – </li>
<li><strong>NumPoles</strong> (<em>int</em>) – </li>
<li><strong>Poles</strong> (<em>float &amp;</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>ConstraintPoint</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Continuity</strong> (<em>int</em>) – </li>
<li><strong>After</strong> (<em>bool</em>) – </li>
<li><strong>NbPolesResult</strong> (<em>int &amp;</em>) – </li>
<li><strong>NbKnotsRsult</strong> (<em>int &amp;</em>) – </li>
<li><strong>KnotsResult</strong> (<em>float &amp;</em>) – </li>
<li><strong>PolesResult</strong> (<em>float &amp;</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Trimming">
<code class="descname">bsplclib_Trimming</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Trimming" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Periodic</strong> (<em>bool</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>U1</strong> (<em>float</em>) – </li>
<li><strong>U2</strong> (<em>float</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>U1</strong> – </li>
<li><strong>U2</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Periodic</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>U1</strong> – </li>
<li><strong>U2</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.bsplclib_Unperiodize">
<code class="descname">bsplclib_Unperiodize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.bsplclib_Unperiodize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Degree</strong> (<em>int</em>) – </li>
<li><strong>Dimension</strong> (<em>int</em>) – </li>
<li><strong>Mults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>Knots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Poles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>NewMults</strong> (<em>TColStd_Array1OfInteger &amp;</em>) – </li>
<li><strong>NewKnots</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewPoles</strong> (<a class="reference internal" href="OCC.TColgp.html#OCC.TColgp.TColgp_Array1OfPnt2d" title="OCC.TColgp.TColgp_Array1OfPnt2d"><em>TColgp_Array1OfPnt2d</em></a>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> (<em>TColStd_Array1OfReal &amp;</em>) – </li>
<li><strong>Degree</strong> – </li>
<li><strong>Mults</strong> – </li>
<li><strong>Knots</strong> – </li>
<li><strong>Poles</strong> – </li>
<li><strong>Weights</strong> – </li>
<li><strong>NewMults</strong> – </li>
<li><strong>NewKnots</strong> – </li>
<li><strong>NewPoles</strong> – </li>
<li><strong>NewWeights</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">void</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">void</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="OCC.BSplCLib.register_handle">
<code class="descname">register_handle</code><span class="sig-paren">(</span><em>handle</em>, <em>base_object</em><span class="sig-paren">)</span><a class="headerlink" href="#OCC.BSplCLib.register_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts the handle into the base object to
prevent memory corruption in certain cases</p>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Thomas Paviot.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.18',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>